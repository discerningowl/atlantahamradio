<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' 'wasm-unsafe-eval' https://cdn.jsdelivr.net https://unpkg.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; connect-src 'self' https://cdn.jsdelivr.net https://unpkg.com blob: data:; worker-src blob:; font-src data:; child-src blob:;">

    <!-- Primary Meta Tags -->
    <title>ICS-205 to CHIRP Converter - Atlanta Ham Radio</title>
    <meta name="title" content="ICS-205 to CHIRP Converter - Atlanta Ham Radio">
    <meta name="description" content="Convert ICS-205 Radio Communications Plan PDFs to CHIRP CSV format for easy radio programming. Free browser-based tool for amateur radio operators.">
    <meta name="keywords" content="ICS-205, CHIRP converter, radio programming, PDF to CSV, amateur radio, ham radio tools, ARES, emergency communications">
    <meta name="author" content="KQ4JP">
    <link rel="canonical" href="https://atlantahamradio.org/pages/ics205-converter.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://atlantahamradio.org/pages/ics205-converter.html">
    <meta property="og:title" content="ICS-205 to CHIRP Converter">
    <meta property="og:description" content="Convert ICS-205 Radio Communications Plan PDFs to CHIRP CSV format for easy radio programming.">
    <meta property="og:image" content="https://atlantahamradio.org/images/logo.png">
    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="Atlanta Ham Radio">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://atlantahamradio.org/pages/ics205-converter.html">
    <meta name="twitter:title" content="ICS-205 to CHIRP Converter">
    <meta name="twitter:description" content="Convert ICS-205 Radio Communications Plan PDFs to CHIRP CSV format for easy radio programming.">
    <meta name="twitter:image" content="https://atlantahamradio.org/images/logo.png">

    <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
    <link rel="stylesheet" href="../css/style.css">

    <style>
        /* Upload Zone Styling */
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 0.75rem;
            padding: 3rem 2rem;
            text-align: center;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 2rem 0;
        }

        .upload-zone:hover {
            border-color: var(--accent);
            background: var(--card-hover-bg);
        }

        .upload-zone.dragover {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
            transform: scale(1.02);
        }

        .upload-zone svg {
            width: 64px;
            height: 64px;
            margin: 0 auto 1rem;
            opacity: 0.5;
        }

        .upload-zone h3 {
            margin: 0 0 0.5rem 0;
            color: var(--text-primary);
        }

        .upload-zone p {
            margin: 0;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Status Box */
        .status-box {
            background: var(--card-bg);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin: 2rem 0;
            display: none;
            text-align: center;
        }

        .status-box.show {
            display: block;
        }

        .status-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .status-icon {
            width: 48px;
            height: 48px;
        }

        .status-icon.info { color: #3b82f6; }
        .status-icon.success { color: #22c55e; }
        .status-icon.error { color: #ef4444; }
        .status-icon.warning { color: #f59e0b; }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            display: none;
        }

        .progress-bar.show {
            display: block;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Results Section */
        .results-section {
            margin: 2rem 0;
            display: none;
        }

        .results-section.show {
            display: block;
        }

        .table-container {
            overflow-x: auto;
            margin: 1.5rem 0;
            border-radius: 0.75rem;
            background: var(--card-bg);
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
        }

        .results-table th,
        .results-table td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .results-table th {
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-weight: 600;
            white-space: nowrap;
        }

        .results-table td {
            color: var(--text-secondary);
        }

        .results-table tr:last-child td {
            border-bottom: none;
        }

        .results-table tbody tr:hover {
            background: var(--card-hover-bg);
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
            flex-wrap: wrap;
        }

        .modal-actions .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .modal-actions .btn svg {
            width: 20px;
            height: 20px;
        }

        /* Debug Section */
        .debug-section {
            margin: 2rem 0;
            display: none;
        }

        .debug-section.show {
            display: block;
        }

        .debug-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1rem;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .debug-box pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: var(--text-secondary);
        }

        .debug-toggle {
            cursor: pointer;
            color: var(--accent);
            text-decoration: underline;
            margin-top: 0.5rem;
            display: inline-block;
        }

        .debug-toggle:hover {
            color: var(--primary);
        }

        @media (max-width: 768px) {
            .upload-zone {
                padding: 2rem 1rem;
            }

            .modal-actions {
                flex-direction: column;
            }

            .modal-actions .btn {
                width: 100%;
                justify-content: center;
            }

            .results-table {
                font-size: 0.85rem;
            }

            .results-table th,
            .results-table td {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <script src="../js/header.js"></script>

    <section class="hero">
        <h2>ICS-205 to CHIRP Converter</h2>
        <p>Convert ICS-205 Radio Communications Plan PDFs to CHIRP-compatible CSV files for easy radio programming.</p>
    </section>

    <section class="article-container">
        <div class="callout info">
            <h3>How to Use</h3>
            <ol>
                <li>Upload your ICS-205 PDF (fillable, scanned, or photo)</li>
                <li>Wait for OCR processing (typically 10-30 seconds per page)</li>
                <li>Review the extracted channels in the preview table</li>
                <li>Click "Download CSV" to save the CHIRP-compatible file</li>
                <li>Import the CSV into CHIRP to program your radio</li>
            </ol>
        </div>

        <div class="callout warning">
            <h3>Important Notes</h3>
            <ul>
                <li><strong>Universal Support:</strong> Works with ANY ICS-205 format (fillable PDF, scanned form, or photo)</li>
                <li><strong>Processing Time:</strong> OCR takes 10-30 seconds per page - please be patient</li>
                <li><strong>Privacy:</strong> All processing happens in your browser - no data is uploaded to a server</li>
                <li><strong>Best Results:</strong> Use clear, high-quality scans with legible text</li>
                <li><strong>Verification:</strong> Always verify frequencies before programming your radio</li>
                <li><strong>Licensing:</strong> Ensure you have proper amateur radio license for programmed frequencies</li>
            </ul>
        </div>

        <!-- Upload Zone -->
        <div class="upload-zone" id="uploadZone">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
            </svg>
            <h3>Drop ICS-205 PDF Here</h3>
            <p>or click to browse</p>
            <input type="file" id="fileInput" accept=".pdf,application/pdf" style="display: none;">
        </div>

        <!-- Status Box -->
        <div class="status-box" id="statusBox">
            <div class="status-content">
                <svg class="status-icon" id="statusIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <p id="statusMessage">Processing PDF...</p>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
        </div>

        <!-- Debug Section -->
        <div class="debug-section" id="debugSection">
            <div class="callout warning">
                <h3>Debug Information</h3>
                <p>The following field names were found in your PDF. This helps identify the correct field mapping:</p>
                <a class="debug-toggle" id="debugToggle" onclick="document.getElementById('debugBox').classList.toggle('show')">Show/Hide Field Names</a>
                <div class="debug-box show" id="debugBox">
                    <pre id="debugContent">No data yet...</pre>
                </div>
                <p style="margin-top: 1rem;"><strong>Next Steps:</strong> If you see field names above, please share a few example field names (especially ones containing frequency or channel information) so we can update the parser to support your ICS-205 form version.</p>
            </div>
        </div>

        <!-- Results Section -->
        <div class="results-section" id="resultsSection">
            <h3>Extracted Channels</h3>
            <div id="channelCount" class="callout tip">
                <p><strong>0 channels</strong> extracted from PDF</p>
            </div>

            <div class="table-container">
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Name</th>
                            <th>RX Freq</th>
                            <th>TX Freq</th>
                            <th>Tone</th>
                            <th>Mode</th>
                        </tr>
                    </thead>
                    <tbody id="previewBody">
                        <!-- Populated dynamically -->
                    </tbody>
                </table>
            </div>

            <div class="modal-actions">
                <button class="btn btn-primary" id="downloadBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                    </svg>
                    Download CHIRP CSV
                </button>
                <button class="btn btn-secondary" id="resetBtn">
                    Start Over
                </button>
            </div>
        </div>

        <div class="callout tip" style="margin-top: 3rem;">
            <h3>Tips for Best Results</h3>
            <ul>
                <li><strong>Complete Forms:</strong> Ensure all frequency rows are filled out completely</li>
                <li><strong>Standard Formats:</strong> Use standard frequency formats (e.g., 146.520, 446.000)</li>
                <li><strong>Tone Codes:</strong> Enter tones as numbers (141.3) or DCS codes (023N)</li>
                <li><strong>Test First:</strong> Always test programmed frequencies before an event</li>
                <li><strong>Save Backups:</strong> Keep a copy of both the PDF and CSV file</li>
            </ul>
        </div>
    </section>

    <script src="../js/footer.js"></script>


    <!-- Tesseract.js OCR Library -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>

    <!-- PDF.js from CDN -->
    <script type="module">
        // Import PDF.js from CDN
        import * as pdfjsLib from 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4/build/pdf.min.mjs';

        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc =
            'https://cdn.jsdelivr.net/npm/pdfjs-dist@4/build/pdf.worker.min.mjs';

        // Global state
        let convertedChannels = [];
        let ocrWorker = null;

        // DOM Elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const statusBox = document.getElementById('statusBox');
        const statusIcon = document.getElementById('statusIcon');
        const statusMessage = document.getElementById('statusMessage');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const debugSection = document.getElementById('debugSection');
        const debugContent = document.getElementById('debugContent');
        const resultsSection = document.getElementById('resultsSection');
        const previewBody = document.getElementById('previewBody');
        const channelCount = document.getElementById('channelCount');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');

        // Event Listeners
        uploadZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);
        downloadBtn.addEventListener('click', handleDownload);
        resetBtn.addEventListener('click', resetConverter);

        // Drag and drop
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');

            const file = e.dataTransfer.files[0];
            if (file) {
                processFile(file);
            }
        });

        // File Selection Handler
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        // Process File
        async function processFile(file) {
            // Validate file type
            if (file.type !== 'application/pdf') {
                showStatus('Please select a PDF file', 'error');
                return;
            }

            // Validate file size (max 10MB)
            if (file.size > 10 * 1024 * 1024) {
                showStatus('File too large (max 10MB)', 'error');
                return;
            }

            showStatus('Reading PDF...', 'info');
            showProgress(5);

            try {
                const arrayBuffer = await file.arrayBuffer();
                showProgress(10);
                await processPDFWithOCR(arrayBuffer);
            } catch (error) {
                console.error('PDF processing error:', error);
                showStatus('Failed to read PDF: ' + error.message, 'error');
                hideProgress();
            }
        }

        // Process PDF with OCR
        async function processPDFWithOCR(arrayBuffer) {
            showStatus('Initializing OCR engine...', 'info');
            showProgress(15);

            try {
                // Check if Tesseract is loaded (use window.Tesseract since it's a global script)
                if (typeof window.Tesseract === 'undefined') {
                    throw new Error('Tesseract.js library failed to load. Please check your internet connection and refresh the page.');
                }

                // Initialize Tesseract worker (v5 API)
                if (!ocrWorker) {
                    console.log('Creating Tesseract worker...');
                    showStatus('Initializing OCR engine... (downloading ~3MB, first time only)', 'info');

                    // Create worker with timeout (no logger to avoid cloning issues)
                    const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('OCR initialization timeout after 60 seconds. Please refresh and try again.')), 60000)
                    );

                    const initPromise = (async () => {
                        ocrWorker = await window.Tesseract.createWorker('eng');
                        console.log('Tesseract worker created and initialized successfully');
                        return ocrWorker;
                    })();

                    ocrWorker = await Promise.race([initPromise, timeoutPromise]);
                }
                showProgress(20);

                // Load PDF
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const numPages = pdf.numPages;
                showStatus(`Processing ${numPages} page(s) with OCR...`, 'info');

                let allChannels = [];
                let allOCRText = '';

                // Process each page
                for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                    showStatus(`OCR processing page ${pageNum} of ${numPages}... (this may take 10-30 seconds)`, 'info');

                    // Render page to canvas
                    const page = await pdf.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better OCR

                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;

                    // Convert canvas to image
                    const imageData = canvas.toDataURL('image/png');

                    // Run OCR
                    const { data: { text } } = await ocrWorker.recognize(imageData);
                    allOCRText += text + '\n\n--- PAGE BREAK ---\n\n';
                    console.log(`OCR Page ${pageNum} text:`, text);

                    // Parse channels from OCR text
                    const channels = parseICS205FromOCR(text);
                    allChannels = allChannels.concat(channels);

                    const progress = 20 + ((pageNum / numPages) * 70);
                    showProgress(progress);
                }

                showProgress(95);

                if (allChannels.length === 0) {
                    // Show OCR text for debugging
                    showDebugInfo(allOCRText);
                    showStatus('No frequency data found. Check debug info below.', 'error');
                    hideProgress();
                    return;
                }

                convertedChannels = allChannels;
                showProgress(100);
                displayResults(allChannels);

            } catch (error) {
                console.error('OCR processing error:', error);
                showStatus('Failed to process PDF with OCR: ' + error.message, 'error');
                hideProgress();
            }
        }

        // Parse ICS-205 from OCR Text
        function parseICS205FromOCR(text) {
            const channels = [];
            const lines = text.split('\n');

            console.log('Parsing OCR text, lines:', lines.length);

            // Find header row to identify columns
            let headerLine = -1;
            let columnMapping = {};

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim().toLowerCase();

                // Look for header row with multiple column indicators
                if ((line.includes('function') || line.includes('owner') || line.includes('name')) &&
                    (line.includes('frequency') || line.includes('freq'))) {
                    headerLine = i;
                    columnMapping = identifyColumns(lines[i]);
                    console.log('Found header at line', i, ':', lines[i]);
                    console.log('Column mapping:', columnMapping);
                    break;
                }
            }

            // Parse data rows
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                // Skip empty lines and header area
                if (!line || line.length < 5) continue;
                if (i <= headerLine + 1) continue; // Skip header and divider

                // Look for lines with frequency data
                const hasFreq = /\b(1[234]\d\.\d{2,5}|2[2-3]\d\.\d{2,5}|4[2-4]\d\.\d{2,5})\b/.test(line);
                if (!hasFreq) continue;

                const channel = parseChannelFromLine(line, lines, i, columnMapping);
                if (channel) {
                    channels.push(channel);
                    console.log('Found channel:', channel);
                }
            }

            return channels;
        }

        // Identify column positions from header row
        function identifyColumns(headerLine) {
            const lower = headerLine.toLowerCase();
            const mapping = {};

            // Function/Owner/Name column (for channel name)
            if (lower.includes('function')) mapping.nameCol = 'function';
            else if (lower.includes('owner')) mapping.nameCol = 'owner';
            else if (lower.includes('name') || lower.includes('net')) mapping.nameCol = 'name';

            // Frequency columns
            if (lower.includes('rx') || lower.includes('receive')) mapping.hasRxCol = true;
            if (lower.includes('tx') || lower.includes('transmit')) mapping.hasTxCol = true;

            // Tone columns
            if (lower.includes('pl') || lower.includes('tone') || lower.includes('ctcss')) mapping.hasToneCol = true;

            return mapping;
        }

        // Parse Channel from OCR Line
        function parseChannelFromLine(line, allLines, lineIndex, columnMapping) {
            // Extract all frequencies from the line
            const freqPattern = /\b(1[234]\d\.\d{2,5}|2[2-3]\d\.\d{2,5}|4[2-4]\d\.\d{2,5})\s*(\([+-]\))?/g;
            const freqMatches = [];
            let match;
            while ((match = freqPattern.exec(line)) !== null) {
                freqMatches.push({
                    freq: match[1],
                    offset: match[2] ? match[2].replace(/[()]/g, '') : null,
                    position: match.index
                });
            }

            if (freqMatches.length === 0) return null;

            // Extract RX frequency (first frequency or labeled RX)
            const rxFreqRaw = freqMatches[0].freq;
            const rxOffset = freqMatches[0].offset;
            const rxFreq = parseFrequency(rxFreqRaw);
            if (!rxFreq) return null;

            // Extract or calculate TX frequency
            let txFreq = rxFreq; // Default to simplex
            const rxNum = parseFloat(rxFreq);

            if (freqMatches.length > 1) {
                // Explicit TX frequency provided in line
                txFreq = parseFrequency(freqMatches[1].freq) || rxFreq;
            } else if (rxOffset) {
                // Calculate from offset indicator (+) or (-)
                if (rxOffset === '+') {
                    if (rxNum >= 144 && rxNum <= 148) txFreq = (rxNum + 0.6).toFixed(6); // 2m +0.6
                    else if (rxNum >= 222 && rxNum <= 225) txFreq = (rxNum + 1.6).toFixed(6); // 1.25m +1.6
                    else if (rxNum >= 420 && rxNum <= 450) txFreq = (rxNum + 5.0).toFixed(6); // 70cm +5.0
                } else if (rxOffset === '-') {
                    if (rxNum >= 144 && rxNum <= 148) txFreq = (rxNum - 0.6).toFixed(6); // 2m -0.6
                    else if (rxNum >= 222 && rxNum <= 225) txFreq = (rxNum - 1.6).toFixed(6); // 1.25m -1.6
                    else if (rxNum >= 420 && rxNum <= 450) txFreq = (rxNum - 5.0).toFixed(6); // 70cm -5.0
                }
            }

            // Extract channel name from Function/Owner/Name column (before first frequency)
            let name = '';
            const beforeFirstFreq = line.substring(0, freqMatches[0].position).trim();
            if (beforeFirstFreq.length > 0) {
                name = beforeFirstFreq
                    .replace(/^\d+\s*[|]?\s*/, '') // Remove leading numbers and pipes
                    .replace(/[|]/g, ' ')
                    .trim();
                const words = name.split(/\s+/).filter(w => w.length > 0);
                name = words.slice(-Math.min(4, words.length)).join(' ');
            }

            // Extract tones: PL Tone / CTCSS = rToneFreq, TSQL/TX Tone = cToneFreq
            const tonePattern = /\b(\d{2,3})(\.\d{1,2})?\b/g;
            const allTones = [];
            let toneMatch;

            while ((toneMatch = tonePattern.exec(line)) !== null) {
                const val = parseFloat(toneMatch[0]);
                // CTCSS tones: 67.0-254.1 Hz
                if (val >= 67.0 && val <= 254.1) {
                    // Make sure it's not part of a frequency
                    let isPartOfFreq = false;
                    for (const fmatch of freqMatches) {
                        if (Math.abs(toneMatch.index - fmatch.position) < 10) {
                            isPartOfFreq = true;
                            break;
                        }
                    }
                    if (!isPartOfFreq) {
                        allTones.push(val.toFixed(1));
                    }
                }
            }

            // Assign tones - first tone is usually TX tone (cToneFreq), same or second is RX (rToneFreq)
            let rToneFreq = ''; // PL Tone / CTCSS Tone (receive)
            let cToneFreq = ''; // TSQL / TX Tone (transmit)

            if (allTones.length > 0) {
                cToneFreq = allTones[0]; // First tone is TX
                rToneFreq = allTones.length > 1 ? allTones[1] : allTones[0]; // Second or same for RX
            }

            // Build comments from remaining data (assignment, remarks, etc.)
            const afterFreqs = line.substring(freqMatches[freqMatches.length - 1].position + 10).trim();
            let remarks = afterFreqs
                .replace(/\b([ADM])\b/g, '') // Remove mode letters
                .replace(/\d{2,3}\.\d{1,2}/g, '') // Remove tones we already extracted
                .replace(/\s+/g, ' ')
                .trim();

            return {
                name: name || 'CHANNEL',
                rxFreq: rxFreq,
                txFreq: txFreq,
                rxTone: rToneFreq, // PL Tone / CTCSS
                txTone: cToneFreq, // TSQL / TX Tone
                mode: 'FM', // Always FM as specified
                remarks: remarks
            };
        }

        // Extract Channel Name from OCR
        function extractChannelName(line, allLines, lineIndex) {
            // Try to find channel name before the frequency
            const freqMatch = line.match(/\b(1[234]\d\.\d{1,4}|2[2-3]\d\.\d{1,4}|4[2-4]\d\.\d{1,4})\b/);
            if (!freqMatch) return '';

            const freqPos = freqMatch.index;
            let beforeFreq = line.substring(0, freqPos).trim();

            // Clean up common OCR artifacts
            beforeFreq = beforeFreq.replace(/[|]/g, ' ').trim();

            // Take last 1-3 words before frequency as channel name
            const words = beforeFreq.split(/\s+/).filter(w => w.length > 0);
            if (words.length > 0) {
                return words.slice(-Math.min(3, words.length)).join(' ');
            }

            return '';
        }

        // Parse Frequency String
        function parseFrequency(freqString) {
            if (!freqString) return null;

            // Remove whitespace and common separators
            freqString = freqString.trim().replace(/[,\s]/g, '');

            // Extract numeric part
            const match = freqString.match(/(\d+\.?\d*)/);
            if (!match) return null;

            const freq = parseFloat(match[1]);

            // Validate frequency range (VHF/UHF amateur bands)
            if ((freq >= 144 && freq <= 148) ||   // 2m
                (freq >= 222 && freq <= 225) ||   // 1.25m
                (freq >= 420 && freq <= 450)) {   // 70cm
                return freq.toFixed(6);
            }

            return null;
        }

        // Parse Tone Code
        function parseTone(toneString) {
            if (!toneString) return { mode: '', tone: '', dcs: '', polarity: 'NN' };

            toneString = toneString.trim();

            // Check for DCS codes (e.g., "023N", "D023N", "023")
            const dcsMatch = toneString.match(/D?(\d{3})([NR])?/i);
            if (dcsMatch) {
                return {
                    mode: 'DTCS',
                    tone: '',
                    dcs: dcsMatch[1],
                    polarity: (dcsMatch[2] || 'N').toUpperCase() + 'N'
                };
            }

            // Check for CTCSS tones (e.g., "141.3", "141.3 Hz")
            const ctcssMatch = toneString.match(/(\d+\.\d+)/);
            if (ctcssMatch) {
                const tone = parseFloat(ctcssMatch[1]);

                // Validate CTCSS range (67.0 - 254.1 Hz)
                if (tone >= 67.0 && tone <= 254.1) {
                    return {
                        mode: 'Tone',
                        tone: tone.toFixed(1),
                        dcs: '',
                        polarity: 'NN'
                    };
                }
            }

            return { mode: '', tone: '', dcs: '', polarity: 'NN' };
        }

        // Calculate Duplex and Offset
        function calculateDuplexOffset(rxFreq, txFreq) {
            if (!txFreq || Math.abs(rxFreq - txFreq) < 0.001) {
                return { duplex: '', offset: '0.000000' }; // Simplex
            }

            const offset = Math.abs(txFreq - rxFreq);

            if (txFreq > rxFreq) {
                return { duplex: '+', offset: offset.toFixed(6) };
            } else {
                return { duplex: '-', offset: offset.toFixed(6) };
            }
        }

        // Determine FM Mode
        function determineMode(modeString, frequency) {
            // Always return FM as specified by user
            return 'FM';
        }

        // Sanitize Channel Name for CHIRP
        function sanitizeChannelName(name) {
            // CHIRP limits: 6-16 characters, alphanumeric + space/dash
            name = name.replace(/[^A-Za-z0-9 \-]/g, '').trim();

            if (name.length > 16) {
                name = name.substring(0, 16);
            }

            if (name.length === 0) {
                name = 'CHANNEL';
            }

            return name;
        }

        // Escape CSV Field
        function escapeCSV(value) {
            value = String(value);

            // Escape quotes and wrap in quotes if contains comma/quote
            if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                value = '"' + value.replace(/"/g, '""') + '"';
            }

            return value;
        }

        // Convert to CHIRP CSV
        function convertToChirpCSV(channels) {
            const csvRows = [];

            // CSV header
            csvRows.push('Location,Name,Frequency,Duplex,Offset,Tone,rToneFreq,cToneFreq,DtcsCode,DtcsPolarity,Mode,TStep,Skip,Comment');

            channels.forEach((channel, index) => {
                const location = index + 1;
                const name = sanitizeChannelName(channel.name);
                const frequency = channel.rxFreq;

                // Determine duplex and offset
                const { duplex, offset } = calculateDuplexOffset(
                    parseFloat(channel.rxFreq),
                    parseFloat(channel.txFreq)
                );

                // Tones are already parsed as strings like "100.0" or "146.2"
                const rToneFreq = channel.rxTone || ''; // PL/CTCSS tone (receive)
                const cToneFreq = channel.txTone || ''; // TSQL/TX tone (transmit)

                // Determine tone mode
                let toneMode = '';
                if (rToneFreq && cToneFreq) {
                    if (rToneFreq === cToneFreq) {
                        toneMode = 'TSQL'; // Tone Squelch (RX and TX same)
                    } else {
                        toneMode = 'Cross'; // Cross tone (different RX/TX)
                    }
                } else if (cToneFreq) {
                    toneMode = 'Tone'; // TX tone only
                }

                // Mode is always FM
                const mode = 'FM';

                // Comments from remarks field
                const comment = (channel.remarks || '').replace(/[\r\n]+/g, ' ').trim();

                // Build CSV row
                const row = [
                    location,
                    name,
                    frequency,
                    duplex,
                    offset,
                    toneMode,
                    rToneFreq, // rToneFreq (receive/PL tone)
                    cToneFreq, // cToneFreq (transmit/TSQL tone)
                    '', // DtcsCode (not used)
                    'NN', // DtcsPolarity (not used)
                    mode,
                    '5.00', // Default tuning step
                    '', // Skip
                    comment
                ];

                csvRows.push(row.map(escapeCSV).join(','));
            });

            return csvRows.join('\n');
        }

        // Display Results
        function displayResults(channels) {
            // Update channel count
            channelCount.querySelector('p').innerHTML =
                `<strong>${channels.length} channel${channels.length !== 1 ? 's' : ''}</strong> extracted from PDF`;

            // Clear previous results
            previewBody.innerHTML = '';

            // Populate table
            channels.forEach((channel, index) => {
                const row = document.createElement('tr');

                const { duplex, offset } = calculateDuplexOffset(
                    parseFloat(channel.rxFreq),
                    parseFloat(channel.txFreq)
                );

                const txDisplay = duplex ?
                    `${channel.rxFreq} ${duplex}${offset}` :
                    channel.txFreq;

                const rxTone = parseTone(channel.rxTone);
                const txTone = parseTone(channel.txTone);
                const toneDisplay = formatToneDisplay(rxTone, txTone);

                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${sanitizeChannelName(channel.name)}</td>
                    <td>${channel.rxFreq}</td>
                    <td>${txDisplay}</td>
                    <td>${toneDisplay}</td>
                    <td>${determineMode(channel.mode, channel.rxFreq)}</td>
                `;

                previewBody.appendChild(row);
            });

            // Show results section
            resultsSection.classList.add('show');

            // Show success status
            showStatus('Conversion complete! Review channels and download CSV.', 'success');
            hideProgress();
        }

        // Format Tone Display
        function formatToneDisplay(rxTone, txTone) {
            if (!rxTone.mode && !txTone.mode) return 'None';

            if (rxTone.mode === 'DTCS' || txTone.mode === 'DTCS') {
                const code = txTone.dcs || rxTone.dcs;
                return `DCS ${code}`;
            }

            if (rxTone.tone && txTone.tone) {
                if (rxTone.tone === txTone.tone) {
                    return `TSQL ${txTone.tone}`;
                } else {
                    return `${txTone.tone}/${rxTone.tone}`;
                }
            }

            if (txTone.tone) {
                return `Tone ${txTone.tone}`;
            }

            return 'Mixed';
        }

        // Handle CSV Download
        function handleDownload() {
            if (convertedChannels.length === 0) {
                showStatus('No channels to download', 'error');
                return;
            }

            const csvContent = convertToChirpCSV(convertedChannels);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'ics205_chirp.csv');
            link.style.display = 'none';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);

            showStatus('CSV downloaded successfully!', 'success');
        }

        // Reset Converter
        async function resetConverter() {
            convertedChannels = [];
            fileInput.value = '';
            statusBox.classList.remove('show');
            debugSection.classList.remove('show');
            resultsSection.classList.remove('show');
            hideProgress();

            // Terminate OCR worker to free memory
            if (ocrWorker) {
                await ocrWorker.terminate();
                ocrWorker = null;
            }
        }

        // Show Status
        function showStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusBox.classList.add('show');

            // Update icon and color
            statusIcon.classList.remove('info', 'success', 'error', 'warning');
            statusIcon.classList.add(type);

            // Icon SVG paths
            const icons = {
                info: 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
                success: 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z',
                error: 'M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z',
                warning: 'M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z'
            };

            statusIcon.innerHTML = `
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${icons[type] || icons.info}" />
            `;
        }

        // Show Progress
        function showProgress(percent) {
            progressBar.classList.add('show');
            progressFill.style.width = percent + '%';
        }

        // Hide Progress
        function hideProgress() {
            progressBar.classList.remove('show');
            progressFill.style.width = '0%';
        }

        // Show Debug Info
        function showDebugInfo(ocrText) {
            const debugSection = document.getElementById('debugSection');
            const debugContent = document.getElementById('debugContent');

            if (!ocrText || ocrText.trim().length === 0) {
                debugContent.textContent = 'No text extracted from PDF. This may indicate a blank or corrupted PDF.';
            } else {
                debugContent.textContent = 'OCR Extracted Text:\n\n' + ocrText;
            }

            debugSection.classList.add('show');
        }
    </script>
</body>
</html>
